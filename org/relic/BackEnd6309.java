/*
 * RELIC BackEnd for the Hitachi 6309/Motorola 6809
 *
 * Converts RELAX intermediate code into native 6309/6809 code that can be assembled by rma.
 *
 * 2009 Boisy G. Pitre
 */
package org.relic;

import org.relic.RelicObject;
import org.relic.util.*;
import java.io.*;
import java.util.*;

public class BackEnd6309 extends RelicObject
{
	static int errorCount = 0, warningCount = 0;
	static SymbolTable symbolTable;
	static QuadTable quadTable;
	static String file = null;
	static Boolean showSummary = false;
	static String sourceFile = null;
	static String destFile = null;
	static AsmTable asm = new AsmTable();

	static String stackMarker = null;
	static int stackOffset = 0;
	static SymbolTable parameters = null;
	
	static int processOptions(String[] args)
	{
		for (int a = 0; a < args.length; a++)
		{
			if (args[a].charAt(0) == '-')
			{
				switch (args[a].charAt(1))
				{
					case 's':
						showSummary = true;
						break;

					default:
						System.err.println("unknown option: " + args[a]);
						return 1;
				}
			}
			else
			{
				if (sourceFile == null)
				{
					sourceFile = args[a];
				}
				else if (destFile == null)
				{
					destFile = args[a];
				}
				else
				{
					// too many file parameters
					return 1;
				}
			}
		}
	
		return 0;
	}
	
	public static void main(String[] args) throws Exception
	{
		if (args.length < 1)
		{
			showHelp();
			return;
		}
		
		if (processOptions(args) == 0)
		{
			process(sourceFile, destFile);
		}
		
		if (showSummary == true)
		{
			int linesTotal = 0;
			int cycleTotal = 0;
			double powerTotal = 0;

			for (Iterator it = asm.iterator(); it.hasNext(); )
			{
				AsmLine l = (AsmLine)it.next();
				linesTotal++;
				cycleTotal += l.cycleCount;
				powerTotal += l.power;
			}

			System.out.println("BackEnd Summary");
			System.out.println("Total lines: " + linesTotal);
			System.out.println("Cycle count: " + cycleTotal);
			System.out.println("Total Power: " + powerTotal + " watts");
		}
	}
		
	public static void showHelp()
	{
		System.err.println("BackEnd6309 v" + version);
		System.err.println("usage: java org.relic.BackEnd6309 infile outfile");
		System.err.println("options:");
		System.err.println("     -s          show summary");
	}
	
	public static String scopeRegister(String name)
	{
		Symbol s = symbolTable.symbolForName(name);
		if (s != null)
		{
			if (s.global == true || s.value != null)
			{
				return "u";
			}
			return "s";
		}

		return "?";
	}
	
	public static int process(String infile, String outfile) throws Exception
	{
		ObjectInputStream s;
		StringToolbox tb = new StringToolbox();
		
		FileInputStream in = new FileInputStream(infile);
		s = new ObjectInputStream(in);

		symbolTable = (SymbolTable)s.readObject();
		quadTable = (QuadTable)s.readObject();

		// Now that we have the symbol and quad tables, start processing
		asm.add(new AsmLine(null, null, null, "Generated by BackEnd6309 " + version));
		asm.add(new AsmLine(null, null, null, null));
//		asm.add(new AsmLine(null, "psect", tb.fileName(infile) + ",0,0,0,0,0", null));
		asm.add(new AsmLine(null, null, null, null));
		createUninitializedDataSegment();
		asm.add(new AsmLine(null, null, null, null));
		createInitializedDataSegment();
		asm.add(new AsmLine(null, null, null, null));
		asm.add(new AsmLine(null, "section", "code", null));
		translate();
		asm.add(new AsmLine(null, "endsect", null, null));
		
		asm.show(outfile);

		return 0;
	}
	
	static Integer createLocalsEQUList(SymbolTable symbolTable)
	{
		Iterator i = symbolTable.entrySet().iterator();
		Integer nextLocation = 0;
		
		asm.add(new AsmLine(null, null, null, "Local equates"));

		while (i.hasNext())
		{
			Map.Entry e = (Map.Entry)i.next();
			Symbol s = (Symbol)e.getValue();
			
			if (s.value != null || s.param != 0)
			{
				// skip over initialized data
				continue;
			}
			
			Integer t = s.size;

			asm.add(new AsmLine(s.name, "equ", nextLocation.toString(), s.type));
			nextLocation += s.size;
			if (s.type.equals("STRING"))
			{
				nextLocation++;
			}
		}
      
      return nextLocation;
	}

	static void createUninitializedDataSegment()
	{
		Iterator i = symbolTable.entrySet().iterator();
		
		asm.add(new AsmLine(null, null, null, "Uninitalized data"));
		asm.add(new AsmLine(null, "section", "bss", null));
		
		while (i.hasNext())
		{
			Map.Entry e = (Map.Entry)i.next();
			Symbol s = (Symbol)e.getValue();
			
			if (s.value != null)
			{
				// skip over initialized data
				continue;
			}
			
			if (s.type.equals("PROCEDURE") || s.type.equals("LABEL") || s.type.equals("UNKNOWN") || s.global == false)
			{
				// ignore the above types - they do not go in the segment
				continue;
			}
			
			Integer t = s.size;
			String name = s.name;
			
			if (s.global == true)
			{
				name += ":";
			}
			
			asm.add(new AsmLine(name, "rmb", t.toString(), s.type));
			if (s.type.equals("STRING"))
			{
				asm.add(new AsmLine(null, "rmb", "1", null));
			}
		}
		
		asm.add(new AsmLine(null, "endsect", null, null));
	}
	
	static void createInitializedDataSegment()
	{
		Iterator i = symbolTable.entrySet().iterator();
		String name, opcode, operand, comment;

		asm.add(new AsmLine(null, null, null, "Initialized data"));
		asm.add(new AsmLine(null, "section", "bss", null));

		while (i.hasNext())
		{
			Map.Entry e = (Map.Entry)i.next();
			Symbol s = (Symbol)e.getValue();
			
			if (s.value == null || s.type.equals("LABEL") || s.type.equals("PROCEDURE"))
			{
				// skip over uninitialized data
				continue;
			}
			
			name = s.name;
			opcode = null;
			operand = s.value;
			comment = s.type + " (" + s.value + ")";

			if (s.global == true)
			{
				name += ":";
			}

			if (s.type.equals("STRING"))
			{
				opcode = "fcc";
			}
			else
			if (s.type.equals("INTEGER"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					if (s.size > 65535)
					{
						System.err.println("WARNING: " + s.size + " exceeds 65535");
					}
					
					opcode = "fdb";
				}
				else
				{
					// INTEGER constants are loaded immediate
					continue;
				}
			}
			else
			if (s.type.equals("BYTE"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					if (s.size > 255)
					{
						System.err.println("WARNING: " + s.size + " exceeds 255");
					}
					
					opcode = "fcb";
				}
				else
				{
					// BYTE constants are loaded immediate
					continue;
				}
			}
			else
			if (s.type.equals("BOOLEAN"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					opcode = "fcb";
					if (s.value.equals("TRUE") || s.value.equals("1"))
					{
						operand = "1";
					}
					else
					{
						operand = "0";
					}
				}
				else
				{
					continue;
				}
			}
			else
			if (s.type.equals("REAL"))
			{
				opcode = "fqb";
				operand = realToIEE754Double(s.value);
			}
			
			asm.add(new AsmLine(name, opcode, operand, comment));
			if (s.type.equals("STRING"))
			{
				asm.add(new AsmLine(null, "fcb", "0", null));
			}
		}

		asm.add(new AsmLine(null, "endsect", null, null));
	}




	static void nop(Quad q)
	{
		asm.add(new AsmLine(q.label, null, null, null));
	}
	
	static void gt(Quad q)
	{
		asm.add(new AsmLine(q.label, "lbra", q.dst, q.comment));
	}
	
	static void logical(Quad q, String operation)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
		asm.add(new AsmLine(null, operation + "b", constructReference(src2), null));
		asm.add(new AsmLine(null, "stb", constructReference(dst), null));
	}
	
	static void _not(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
		asm.add(new AsmLine(null, "bne", null, null));
		asm.add(new AsmLine(null, "ldd", "#0001", null));
		asm.add(new AsmLine(null, "std", constructReference(src2), null));
		asm.add(new AsmLine(null, "bra", null, null));
		asm.add(new AsmLine(null, "ldd", "$0000", null));
		asm.add(new AsmLine(null, "std", constructReference(src2), null));
	}
	
	static void _neg(Quad q)
	{
		Symbol s = (Symbol)symbolTable.get(q.dst);

		if (s.type.equals("INTEGER"))
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(s), q.comment));
			asm.add(new AsmLine(null, "coma", null, null));
			asm.add(new AsmLine(null, "comb", null, null));
			asm.add(new AsmLine(null, "addd", "#$0001", null));
			asm.add(new AsmLine(null, "std", constructReference(s), null));
		}
		else
		if (s.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "ldb", constructReference(s), q.comment));
			asm.add(new AsmLine(null, "comb", null, null));
			asm.add(new AsmLine(null, "incb", null, null));
			asm.add(new AsmLine(null, "stb", constructReference(s), null));
		}
		else
		if (s.type.equals("REAL"))
		{
			asm.add(new AsmLine(q.label, "leax", constructEffectiveReference(s), q.comment));
			asm.add(new AsmLine(null, "lbsr", "negate_Real_at_X", null));
		}
		else
		{
			System.out.println("_neg() encountered an unsupported type.");
		}
	}

	
	/* Legal additions:

		Booleans cannot be added

		Bytes, Integers and Reals can be added together
		BYTE + BYTE = 0-255
		INTEGER + INTEGER = -32768 to 32767
		REAL + REAL = REAL range
		BYTE + INTEGER = -32768 to 32767
		BYTE + REAL = REAL range
		INTEGER + REAL = REAL range
	*/
	static void add(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (src1.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(null, "addb", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "sex", null, null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "sex", null, null));
					asm.add(new AsmLine(null, "leax", constructEffectiveReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "addd", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "add_D_to_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst) + "+2" + "," + scopeRegister(q.dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst) + "+4" + "," + scopeRegister(q.dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst) + "+6" + "," + scopeRegister(q.dst), null));
				}
			}
		}


		else
		if (src1.type.equals("INTEGER"))
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));

			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(null, "addb", constructReference(src2), null));
				asm.add(new AsmLine(null, "adca", "#0", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(null, "addd", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "add_D_to_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", q.dst, null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", q.dst, null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
		}


		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "add_D_to_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "add_D_to_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "leax", constructEffectiveReference(src1), q.comment));
				asm.add(new AsmLine(null, "leay", constructEffectiveReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "add_real_at_X_to_real_at_Y_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
		}


		else
		if (src1.type.equals("STRING"))
		{
			if (src2.type.equals("STRING"))
			{
				Integer size = dst.size;
				Integer originalStackOffset = stackOffset;
            
				asm.add(new AsmLine(q.label, "ldd", "#" + size.toString(), q.comment));
				asm.add(new AsmLine(null, "pshs", "d", null));
				stackOffset += 2;

				asm.add(new AsmLine(null, "leax", constructReference(dst), null));
				asm.add(new AsmLine(null, "pshs", "x", null));
				stackOffset += 2;

	            asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "pshs", "x", null));
				stackOffset += 2;
	
				asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "pshs", "x", null));
				stackOffset += 2;

				asm.add(new AsmLine(null, "lbsr", "addstring", "addstring(src1addr, src2addr, dstaddr, dstsize)"));
				asm.add(new AsmLine(null, "leas", "8,s", null));

				stackOffset = originalStackOffset;
			}
			else
			{
				System.out.println("STRING can only be added to STRING");
			}
		}
	}
	

	/* Legal subtractions:

		Booleans cannot be subtracted

		Bytes, Integers and Reals can be subtracted from each other
		BYTE - BYTE = 0-255
		INTEGER - INTEGER = -32768 to 32767
		REAL - REAL = REAL range
		BYTE - INTEGER = -32768 to 32767
		BYTE - REAL = REAL range
		INTEGER - REAL = REAL range
	*/
	static void subtract(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (src1.type.equals("BYTE"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "subb", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "sex", null, null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "sex", null, null));
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "subd", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "subtract_real_at_X_from_D_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
		}


		else
		if (src1.type.equals("INTEGER"))
		{
			if (src2.type.equals("BYTE"))
			{
				Integer originalStackOffset = stackOffset;

				asm.add(new AsmLine(q.label, "ldb", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "pshs", "d", null));
                stackOffset += 2;
				asm.add(new AsmLine(null, "ldd", constructReference(src1), null));
				asm.add(new AsmLine(null, "subd", ",s++", null));
				stackOffset -= 2;
				
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
				
				stackOffset = originalStackOffset;
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "subd", constructReference(src2), null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "leax", constructReference(dst), null));
					asm.add(new AsmLine(null, "lbsr", "assign_D_to_real_at_X", null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "subtract_real_at_X_from_D_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
		}


		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "subtract_D_from_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "subtract_D_from_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "leax", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leay", constructEffectiveReference(src2), null));
				asm.add(new AsmLine(null, "leas", "-8,s", null));
				asm.add(new AsmLine(null, "lbsr", "subtract_real_at_Y_from_real_at_X_to_2s", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "tfr", "s,x", null));
					asm.add(new AsmLine(null, "lbsr", "assign_real_at_X_to_D", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					asm.add(new AsmLine(null, "leas", "8,s", null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 2), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 4), null));
					asm.add(new AsmLine(null, "puls", "d", null));
					asm.add(new AsmLine(null, "std", constructReference(dst, 6), null));
				}
			}
		}
	}
	

	/* Legal multiplications:

		Booleans cannot be multiplied

		Bytes, Integers and Reals can be multiplied together
		BYTE * BYTE = 0-255
		INTEGER * INTEGER = -32768 to 32767
		REAL * REAL = REAL range
		BYTE * INTEGER = -32768 to 32767
		BYTE * REAL = REAL range
		INTEGER * REAL = REAL range
	*/
	static void multiply(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (src1.type.equals("BYTE"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "ldb", constructReference(src2), null));
				asm.add(new AsmLine(null, "mul", null, null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE * BYTE"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "ldx", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "signed_multiply_integer_byte", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE * INTEGER"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "multiply_real_byte", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", q.dst, null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", q.dst, null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE * REAL"));
				}
			}
		}


		else
		if (src1.type.equals("INTEGER"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "ldx", constructReference(src1), null));
				asm.add(new AsmLine(null, "lbsr", "signed_multiply_integer_byte", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER * BYTE\n"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "ldx", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "signed_multiply_integer_integer", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER * INTEGER\n"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "multiply_real_integer", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "stb", q.dst, null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, "std", q.dst, null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER * REAL\n"));
				}
			}
		}


		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL * BYTE\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL * BYTE\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL * BYTE\n"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL * INTEGER\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL * INTEGER\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL * INTEGER\n"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL * REAL\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL * REAL\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL * REAL\n"));
				}
			}
		}
	}
	
	static void divide(Quad q)
	{
		divide_common(q, true);
	}
	
	static void modulus(Quad q)
	{
		divide_common(q, false);
	}
	
	static void divide_common(Quad q, Boolean doDivide)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (src1.type.equals("BYTE"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "ldb", constructReference(src1) , null));
				asm.add(new AsmLine(null, "lbsr", "byte_div_byte", null));

				if (dst.type.equals("BYTE"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "sta", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == false)
						asm.add(new AsmLine(null, "tfr", "a,b", null));
					asm.add(new AsmLine(null, "sex", null, null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE [/%] BYTE"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "tfr", "d,x", null));
				asm.add(new AsmLine(null, "ldd", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "byte_div_integer", null));

				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, "tfr", "x,d", null));
					if (doDivide == true)
						asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "sta", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == false)
						asm.add(new AsmLine(null, "std", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "stx", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE [/%] INTEGER"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "real_div_byte", null));

				if (dst.type.equals("BYTE"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "sta", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "std", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "stx", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = BYTE [/%] REAL"));
				}
			}
		}


		else
		if (src1.type.equals("INTEGER"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "ldx", constructReference(src1), null));
				asm.add(new AsmLine(null, "lbsr", "integer_div_byte", null));

				if (dst.type.equals("BYTE"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "sta", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == false)
						asm.add(new AsmLine(null, "tfr", "a,b", null));
					asm.add(new AsmLine(null, "clra", null, null));
					asm.add(new AsmLine(null, "std", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER / BYTE\n"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "ldx", constructReference(src1), null	));
				asm.add(new AsmLine(null, "lbsr", "integer_div_integer", null));

				if (dst.type.equals("BYTE"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "tfr", "x,d", null));
					asm.add(new AsmLine(null, "stb", constructReference(dst), null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == false)
						asm.add(new AsmLine(null, "tfr", "d,x", null));
					asm.add(new AsmLine(null, "stx", constructReference(dst), null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER [/%] INTEGER\n"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "integer_div_real", null));

				if (dst.type.equals("BYTE"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "stb", constructReference(dst), null));
					else
						asm.add(new AsmLine(null, "sta", q.dst, null));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					if (doDivide == true)
						asm.add(new AsmLine(null, "tfr", "x,d", null));
					asm.add(new AsmLine(null, "clra", null, null));
					asm.add(new AsmLine(null, "std", q.dst, null));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = INTEGER [/%] REAL\n"));
				}
			}
		}


		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL / BYTE\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL / BYTE\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL / BYTE\n"));
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL / INTEGER\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL / INTEGER\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL / INTEGER\n"));
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
				if (dst.type.equals("BYTE"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: BYTE = REAL / REAL\n"));
				}
				else
				if (dst.type.equals("INTEGER"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: INTEGER = REAL / REAL\n"));
				}
				else
				if (dst.type.equals("REAL"))
				{
					asm.add(new AsmLine(null, null, null, "TODO: REAL = REAL / REAL\n"));
				}
			}
		}
	}
	
	static void rem(Quad q)
	{
	}
	
	static void stack(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "lda", constructReference(dst), q.comment));
			asm.add(new AsmLine(null, "pshs", "a", null));
			stackOffset += 1;
		}
		else if (dst.type.equals("INTEGER"))
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(dst), q.comment));
			asm.add(new AsmLine(null, "pshs", "d", null));
			stackOffset += 2;
		}
		else if (dst.type.equals("REAL"))
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(dst), q.comment));
			asm.add(new AsmLine(null, "pshs", "d", null));
			stackOffset += 2;
			asm.add(new AsmLine(null, "ldd", constructReference(dst), null));
			asm.add(new AsmLine(null, "pshs", "d", null));
			stackOffset += 2;
			asm.add(new AsmLine(null, "lda", constructReference(dst), null));
			asm.add(new AsmLine(null, "pshs", "a", null));
			stackOffset += 1;
		}
	}
	
	static void unstack(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "puls", "a", q.comment));
			stackOffset -= 1;
			asm.add(new AsmLine(null, "sta", constructReference(dst), null));
		}
		else if (dst.type.equals("INTEGER"))
		{
			asm.add(new AsmLine(q.label, "puls", "d", q.comment));
			stackOffset -= 2;
			asm.add(new AsmLine(null, "std", constructReference(dst), null));
		}
		else if (dst.type.equals("REAL"))
		{
			asm.add(new AsmLine(q.label, "puls", "d", q.comment));
			stackOffset -= 2;
			asm.add(new AsmLine(null, "std", constructReference(dst), null));
			asm.add(new AsmLine(null, "puls", "d", null));
			stackOffset -= 2;
			asm.add(new AsmLine(null, "std", constructReference(dst), null));
			asm.add(new AsmLine(null, "puls", "a", null));
			stackOffset -= 1;
			asm.add(new AsmLine(null, "sta", constructReference(dst), null));
		}
	}
	
	/* Legal copies:

		Boolean is an 8-bit value (0 = FALSE, 1 = TRUE)
		BOOLEAN = BOOLEAN

		Byte is an Unsigned 8-bit value (0-255)
		BYTE = BYTE
		BYTE = INTEGER % 256
		BYTE = REAL % 256
		
		Integer is a Signed 16-bit value (-32768 to 32767)
		INTEGER = BYTE
		INTEGER = INTEGER
		INTEGER = REAL % 65536
		
		REAL = BYTE
		REAL = INTEGER
		REAL = REAL
		
		STRING = STRING
	 */
	static void cp(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol dst = (Symbol)symbolTable.get(q.dst);

		if (src1.type.equals("BOOLEAN"))
		{
			if (dst.type.equals("BOOLEAN"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sta", constructReference(dst), null));
			}
			else
			{
				System.out.println("BOOLEAN can only be assigned to BOOLEAN");
			}
		}
		else
		if (src1.type.equals("BYTE"))
		{
			if (dst.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "lda", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sta", constructReference(dst), null));
			}
			else
			if (dst.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "std", constructReference(dst), null));
			}
			else
			if (dst.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, null, null, "TODO: REAL = BYTE"));
			}
		}
		else
		if (src1.type.equals("INTEGER"))
		{
			if (dst.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1, 1), q.comment));
				asm.add(new AsmLine(null, "stb", constructReference(dst), null));
			}
			else
			if (dst.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "std", constructReference(dst), null));
			}
			else
			if (dst.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, null, null, "TODO: REAL = INTEGER"));
			}
		}
		else
		if (src1.type.equals("REAL"))
		{
			if (dst.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, null, null, "TODO: BYTE = REAL"));
			}
			else
			if (dst.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, null, null, "TODO: INTEGER = REAL"));
			}
			else
			if (dst.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "ldd", q.src1 + "," + scopeRegister(q.src1), q.comment));
				asm.add(new AsmLine(null, "std", q.dst + "," + scopeRegister(q.dst), null));

				asm.add(new AsmLine(null, "ldd", q.src1 + "+2" + "," + scopeRegister(q.src1), null));
				asm.add(new AsmLine(null, "std", q.dst + "+2" + "," + scopeRegister(q.dst), null));

				asm.add(new AsmLine(null, "ldd", q.src1 + "+4" + "," + scopeRegister(q.src1), null));
				asm.add(new AsmLine(null, "std", q.dst + "+4" + "," + scopeRegister(q.dst), null));

				asm.add(new AsmLine(null, "ldd", q.src1 + "+6" + "," + scopeRegister(q.src1), null));
				asm.add(new AsmLine(null, "std", q.dst + "+6" + "," + scopeRegister(q.dst), null));
			}
		}
		else
		if (src1.type.equals("STRING"))
		{
			if (dst.type.equals("STRING"))
			{
				Integer size = dst.size;
				Integer originalStackOffset = stackOffset;
            
				asm.add(new AsmLine(q.label, "ldd", "#" + size.toString(), q.comment));
				asm.add(new AsmLine(null, "leax", constructReference(dst), null));
				asm.add(new AsmLine(null, "pshs", "x,d", null));
				stackOffset += 4;

				size = src1.size;				
				asm.add(new AsmLine(q.label, "ldd", "#" + size.toString(), null));
	
	            asm.add(new AsmLine(null, "leax", constructReference(src1), null));
				asm.add(new AsmLine(null, "pshs", "x,d", null));
				asm.add(new AsmLine(null, "lbsr", "copystring", "copystring(srcsize, srcaddr, dstsize, dstaddr)"));
				asm.add(new AsmLine(null, "leas", "8,s", null));
				
				stackOffset = originalStackOffset;
			}
			else
			{
				System.out.println("STRING can only be assigned to STRING");
			}
		}
	}

	static String constructReference(Symbol ref)
	{
		return constructReference(ref, 0);
	}
	
	static String constructEffectiveReference(Symbol ref)
	{
		return constructReference(ref, 0, true);
	}
	
	static String constructReference(Symbol ref, int offset)
	{
		return constructReference(ref, offset, false);
	}
	
	static String constructReference(Symbol ref, int offset, Boolean effective)
	{
		// if this symbol is a read only constant, return the immediate form
		if (effective == false && ref.type.equals("STRING") == false && quadTable.symbolIsReadOnlyConstant(ref))
		{
			String value = ref.value;
			
			if (ref.type.equals("BOOLEAN"))
			{
				if (value.equals("FALSE"))
				{
					value = "0";
				}
				else
				{
					value = "1";
				}
			}
			return "#" + value;
		}
		else
		if (parameters.containsValue(ref) && ref.param > 0)
		{
			// parameter -- construct reference to value on stack
			int parameterLocationOnStack = parameters.getTotalSizesUpToSymbol(ref);
			int distanceToParameter = stackOffset + 2 + parameterLocationOnStack;	// add 2 for return address on stack
			return stackMarker + "+" + distanceToParameter + ",s";
		}
		else
		{
			if (scopeRegister(ref.name) == "s")
			{
				// reference is to something on the stack
				int distanceToReference = offset + stackOffset;	// add 2 for return address on stack
				return ref.name + "+" + distanceToReference + ",s";
			}
			else
			{
				if (offset != 0)
				{
					return ref.name + "+" + offset + "," + scopeRegister(ref.name);
				}
				else
				{
					return ref.name + "," + scopeRegister(ref.name);
				}
			}
		}
	}
	
	static void gtconditional(Quad q)
	{
		String opcode = null;
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		
		if (src1.type.equals("BOOLEAN"))
		{
			if (!src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
			}

			asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
			asm.add(new AsmLine(null, "cmpb", constructReference(src2), null));			
		}
		else
		if (src1.type.equals("BYTE"))
		{
			if (src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
			}
			else
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "cmpb", constructReference(src2), null));
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));			
				asm.add(new AsmLine(null, "cmpd", constructReference(src2), null));			
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, null, null, "* TODO: BYTE != REAL"));
			}
		}

		else
		if (src1.type.equals("INTEGER"))
		{
			if (src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
			}
			else
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "sex", null, null));
				asm.add(new AsmLine(null, "cmpd", constructReference(src1), null));
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));
				asm.add(new AsmLine(null, "cmpd", constructReference(src2), null));			
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, null, null, "* TODO: INTEGER != REAL"));
			}
		}

		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
			}
			else
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, null, null, "* TODO: REAL != BYTE"));
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, null, null, "* TODO: REAL != INTEGER"));
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, null, null, "* TODO: REAL != REAL"));
			}
		}

		if (q.opcode.equals("gt>="))
		{
			opcode = "lbge";
		}
		else
		if (q.opcode.equals("gt<="))
		{
			opcode = "lble";
		}
		else
		if (q.opcode.equals("gt>"))
		{
			opcode = "lbgt";
		}
		else
		if (q.opcode.equals("gt<"))
		{
			opcode = "lblt";
		}
		else
		if (q.opcode.equals("gt!="))
		{
			opcode = "lbne";
		}
		else
		{
			opcode = "lbeq";
		}

		asm.add(new AsmLine(null, opcode, q.dst, null));
	}
	
	static void relation(Quad q)
	{
		String opcode = null;
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		
		if (q.opcode.equals(">"))
		{
			opcode = "bgt";
		}
		else
		if (q.opcode.equals("<"))
		{
			opcode = "blt";
		}
		else
		if (q.opcode.equals(">="))
		{
			opcode = "bge";
		}
		else
		if (q.opcode.equals("<="))
		{
			opcode = "ble";
		}
		else
		if (q.opcode.equals("="))
		{
			opcode = "beq";
		}
		else
		{
			opcode = "bne";
		}

		if (src1.type.equals("BOOLEAN"))
		{
			if (!src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
				return;
			}

			asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));			
			asm.add(new AsmLine(null, "cmpb", constructReference(src2), null));			
		}

		else
		if (src1.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "ldb", constructReference(src1), q.comment));			

			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(null, "cmpb", constructReference(src2), null));			
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(null, "clra", null, null));			
				asm.add(new AsmLine(null, "cmpd", constructReference(src2), null));			
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(null, "clra", null, null));			
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src2), null));			
				asm.add(new AsmLine(null, "lbsr", "cmp_D_to_real_at_X", null));			
			}
		}

		else
		if (src1.type.equals("INTEGER"))
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(src1), q.comment));			

			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(null, "tfr", "d,x", null));
				asm.add(new AsmLine(null, "ldb", constructReference(src2), null));			
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "pshs", "d", null));
				asm.add(new AsmLine(null, "cmpd", ",s++", null));
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(null, "cmpd", constructReference(src2), null));			
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src2), null));			
				asm.add(new AsmLine(null, "lbsr", "cmp_D_to_real_at_X", null));			
			}
		}

		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
				asm.add(new AsmLine(q.label, "ldb", constructReference(src2), q.comment));			
				asm.add(new AsmLine(null, "clra", null, null));
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src1), null));
				asm.add(new AsmLine(null, "lbsr", "cmp_real_at_X_to_D", null));
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				asm.add(new AsmLine(q.label, "ldd", constructReference(src2), q.comment));
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src1), null));
				asm.add(new AsmLine(null, "lbsr", "cmp_real_at_X_to_D", null));
			}
			else
			if (src2.type.equals("REAL"))
			{
				asm.add(new AsmLine(q.label, "leay", constructEffectiveReference(src2), q.comment));
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src1), null));
				asm.add(new AsmLine(null, "lbsr", "cmp_real_at_X_to_real_at_Y", null));
			}
		}

		else
		if (src1.type.equals("STRING"))
		{
			if (src2.type.equals("STRING"))
			{
				asm.add(new AsmLine(q.label, "leay", constructEffectiveReference(src1), null));
				asm.add(new AsmLine(null, "leax", constructEffectiveReference(src2), null));
				asm.add(new AsmLine(null, "lbsr", "STRCMP", null));
			}
			else
			{
				System.err.printf("illegal comparison: STRING to another type\n");
				System.exit(1);
			}
		}

		String bra1 = "L" + asm.size();
		asm.add(new AsmLine(null, opcode, bra1, null));
		asm.add(new AsmLine(null, "clrb", null, null));
		String bra2 = "L" + asm.size();
		asm.add(new AsmLine(null, "bra", bra2, null));
		asm.add(new AsmLine(bra1, "ldb", "#$01", null));
		asm.add(new AsmLine(bra2, "stb", constructReference(dst), null));
	}
	
	static void ret(Quad q, String stackSymbol)
	{
		if (stackMarker != null)
		{
			asm.add(new AsmLine(q.label, "leas", stackSymbol + ",s", q.comment));
			asm.add(new AsmLine(null, "rts", null, null));
		}
		else
		{
			asm.add(new AsmLine(q.label, "rts", null, q.comment));
		}
	}
	
	static void _exit(Quad q)
	{
		Symbol s = (Symbol)symbolTable.get(q.dst);

		if (s.type.equals("BYTE"))
		{
			asm.add(new AsmLine(q.label, "ldb", constructReference(s), q.comment));
			asm.add(new AsmLine(null, "sex", null, null));
		}
		else
		{
			asm.add(new AsmLine(q.label, "ldd", constructReference(s), q.comment));
		}
		asm.add(new AsmLine(null, "lbra", "_exit", null));
	}
	
	static void call(Quad q)
	{
		asm.add(new AsmLine(null, "lbsr", q.dst, null));
	}
	
	static void translate()
	{
		String procedureName = null;

		for (Iterator it = quadTable.iterator(); it.hasNext(); )
		{
			Quad q = (Quad)it.next();
			asm.add(new AsmLine(null, null, null, q.prettyLine()));

			if (symbolTable.symbolIsProcedure(q.label))
			{
				procedureName = q.label;
				
				// we're at the start of a procedure... generate prologue code
				SymbolTable localSymbolTable = symbolTable.getUninitializedSymbolsForProcedure(procedureName);
				
				Integer stackSize = createLocalsEQUList(localSymbolTable);

				String stkSizLabel = q.label + "__stksiz";
				stackMarker = procedureName + "__stksiz";

				// add stack size equate
				asm.add(new AsmLine(stkSizLabel, "equ", stackSize.toString(), null));
				asm.add(new AsmLine(null, null, null, null));

				if (stackSize > 0)
				{
					String stkClearLabel = q.label + "__stkclear";

					asm.add(new AsmLine(q.label + ":", "ldd", "#" + stackMarker, "allocate stack space"));
					asm.add(new AsmLine(stkClearLabel, "clr", ",-s", null));
					asm.add(new AsmLine(null, "subd", "#$0001", null));
					asm.add(new AsmLine(null, "bne", stkClearLabel, null));
				}
				else
				{
					asm.add(new AsmLine(q.label + ":", null, null, null));
				}
				q.label = "";
			}

			// get theparameters for this procedure
			parameters = symbolTable.getParametersForProcedure(procedureName);
			
			// attach ":" to label if its global
			if (q.label != null && q.label != "" && symbolTable.symbolIsGlobal(q.label))
			{
				q.label = q.label + ":";
			}

			if (q.opcode.equalsIgnoreCase("nop"))
			{
				nop(q);
			}
			else if (q.opcode.equalsIgnoreCase("gt"))
			{
				gt(q);
			}
			else if (q.opcode.equalsIgnoreCase("and"))
			{
				logical(q, "and");
			}
			else if (q.opcode.equalsIgnoreCase("or"))
			{
				logical(q, "or");
			}
			else if (q.opcode.equalsIgnoreCase("not"))
			{
				_not(q);
			}
			else if (q.opcode.equalsIgnoreCase("neg"))
			{
				_neg(q);
			}
			else if (q.opcode.equalsIgnoreCase("+"))
			{
				add(q);
			}
			else if (q.opcode.equalsIgnoreCase("-"))
			{
//				Assembler localAsm = new Assembler(cpu, new OS9Emitter());
				subtract(q);
//				localAsm.assemble(null, true, true, true);
//				asm.addAll(localAsm);
			}
			else if (q.opcode.equalsIgnoreCase("*"))
			{
				multiply(q);
			}
			else if (q.opcode.equalsIgnoreCase("/"))
			{
				divide(q);
			}
			else if (q.opcode.equalsIgnoreCase("%"))
			{
				modulus(q);
			}
			else if (q.opcode.equalsIgnoreCase("rem"))
			{
				rem(q);
			}
			else if (q.opcode.equalsIgnoreCase("stack"))
			{
				stack(q);
			}
			else if (q.opcode.equalsIgnoreCase("unstack"))
			{
				unstack(q);
			}
			else if (q.opcode.equalsIgnoreCase("cp"))
			{
				cp(q);
			}
			else
			if (q.opcode.equalsIgnoreCase("gt!=")
				|| q.opcode.equalsIgnoreCase("gt=")
				|| q.opcode.equalsIgnoreCase("gt>=")
				|| q.opcode.equalsIgnoreCase("gt<=")
				|| q.opcode.equalsIgnoreCase("gt>")
				|| q.opcode.equalsIgnoreCase("gt<")
			)
			{
				gtconditional(q);
			}
			else if (q.opcode.equalsIgnoreCase(">")
			|| q.opcode.equalsIgnoreCase("<")
			|| q.opcode.equalsIgnoreCase(">=")
			|| q.opcode.equalsIgnoreCase("<=")
			|| q.opcode.equalsIgnoreCase("=")
			|| q.opcode.equalsIgnoreCase("<>")
			)
			{
				relation(q);
			}
			else if (q.opcode.equalsIgnoreCase("ret"))
			{
				ret(q, procedureName + "__stksiz");
			}
			else if (q.opcode.equalsIgnoreCase("exit"))
			{
				_exit(q);
			}
			else if (q.opcode.equalsIgnoreCase("call"))
			{
				call(q);
			}
			else
			{
				System.err.printf("unknown instruction '%s'\n", q.opcode);
				System.exit(1);
			}
		}
	}

	// Format of a Real:
	// SEEEEEEEEMMMMMMMMMMMMMMMMMMMMMMM
	//
	// Format of a Basic09 REAL (not used):
	// Byte 1:     8-bit Exponent (2^-128 to 2^127)
	// Bytes 2-5: 31-bit Mantissa (.5 - .9999999995 with values .000000005 apart)
	//             1-bit Sign
	static String realToIEE754Double(String real)
	{
		Double value = 0.0;
		
		try
		{
			value = Double.valueOf(real.trim()).doubleValue();
		}
		catch (NumberFormatException nfe)
		{
			System.out.println("NumberFormatException: " + nfe.getMessage());
		}

		String ieee754 = Long.toHexString(Double.doubleToLongBits(value));

		return "$" + ieee754.substring(0, 7) + ",$"+ ieee754.substring(8);
	}
}
