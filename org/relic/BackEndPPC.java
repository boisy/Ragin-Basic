/*
 * RELIC BackEnd for the PowerPC
 *
 * Converts RELAX intermediate code into native PowerPC code.
 *
 * 2009 Boisy G. Pitre
 * 
 * Common PowerPC ABI:
 *   Register    Classification    Notes
 *   r0          local             commonly used to hold the old link register when building the stack frame
 *   r1          dedicated         stack pointer
 *   r2          dedicated         table of contents pointer
 *   r3          local             commonly used as the return value of a function, and also the first argument in
 *   r4–r10      local             commonly used to send in arguments 2 through 8 into a function (caller save)
 *   r11–r12     local	
 *   r13–r31     global	
 *   lr          dedicated         link register; cannot be used as a general register. Use mflr (move from link register) or mtlr (move to link register) to get at, e.g., mtlr r0
 *   cr          dedicated         condition register
*/
package org.relic;

import org.antlr.runtime.*;
import org.relic.util.*;
import java.io.*;
import java.util.*;

public class BackEndPPC extends RelicObject
{
	static int errorCount = 0, warningCount = 0;
	static SymbolTable symbolTable;
	static QuadTable quadTable;
	static AsmTable asmTable = new AsmTable();
	static String file = null;
	static String alignment = "2";
	static String target = "ppc";
	static String infile = null, outfile = null;
   static Integer maxByteValue = 255;
   static Integer maxIntegerValue = 32767;
        static int stackOffset = 0;
   
	private static String hi16(String register)
	{
		if (target.equals("ppc"))
		{
			return "ha16(" + register + ")";
		}
		else
		{
			return register + "@ha";
		}
	}
	
	private static String lo16(String register)
	{
		if (target.equals("ppc"))
		{
			return "lo16(" + register + ")";
		}
		else
		{
			return register + "@l";
		}
	}
	
    public static void main(String[] args) throws Exception
	{
		if (args.length < 2)
		{
			showHelp();
			return;
		}
		
		if (processOptions(args) == 0)
		{
			if (infile == null || outfile == null)
			{
			}
			else
			{
				process(target, infile, outfile);
			}
		}
	}
		
	static int processOptions(String[] args)
	{
		for (int a = 0; a < args.length; a++)
		{
			if (args[a].charAt(0) == '-')
			{
				switch (args[a].charAt(1))
				{
					case 't':
						target = args[a].substring(3, args[a].length());
						break;
						
					default:
						System.err.println("unknown option: " + args[a]);
						return 1;
				}
			}
			else
			{
				if (infile == null)
				{
					infile = args[a];
				}
				else if (outfile == null)
				{
					outfile = args[a];
				}
			}
		}
		
		return 0;
	}
	
	public static void showHelp()
	{
		System.err.println("BackEndPPC v" + version);
		System.err.println("usage: java org.relic.BackEndPPC infile outfile");
	}
	
	public static int process(String desiredTarget, String infile, String outfile) throws Exception
	{
		ObjectInputStream s;
		StringToolbox tb = new StringToolbox();
		target = desiredTarget;
		
		FileInputStream in = new FileInputStream(infile);
		s = new ObjectInputStream(in);

		symbolTable = (SymbolTable)s.readObject();
		quadTable = (QuadTable)s.readObject();

		// Now that we have the symbol and quad tables, start processing
		asmTable.add(new GNUAsmLine(null, null, null, "Generated by BackEndPPC " + version));
		asmTable.add(new GNUAsmLine(null, null, null, null));
		asmTable.add(new GNUAsmLine(null, null, null, null));
		createUninitializedDataSegment();
		asmTable.add(new GNUAsmLine(null, null, null, null));
		createInitializedDataSegment();
		asmTable.add(new GNUAsmLine(null, null, null, null));
		translate();
		
		asmTable.show(outfile);
		
		return 0;
	}
	
	static void createUninitializedDataSegment()
	{
		Iterator i = symbolTable.entrySet().iterator();
		
		asmTable.add(new GNUAsmLine(null, null, null, "Uninitalized data"));
		asmTable.add(new GNUAsmLine(null, ".data", null, null));
		asmTable.add(new GNUAsmLine(null, ".align", alignment, "align to " + (2 * new Integer(alignment).intValue()) + " byte boundary"));

		while (i.hasNext())
		{
			Map.Entry e = (Map.Entry)i.next();
			Symbol s = (Symbol)e.getValue();
			
			if (s.value != null)
			{
				// skip over initialized data
				continue;
			}
			
			if (s.type.equals("PROCEDURE") || s.type.equals("LABEL") || s.type.equals("UNKNOWN"))
			{
				// ignore the above types - they do not go in the segment
				continue;
			}

			Integer t = s.size;
			if (s.global == true)
			{
//				s.name += ":";
			}

			if (s.type.equals("STRING"))
			{
				t = t + 1;
			}
			asmTable.add(new GNUAsmLine(null, ".comm", s.name + "," + t.toString(), s.type));
		}
		
	}

	static void createInitializedDataSegment()
	{
		Iterator i = symbolTable.entrySet().iterator();
		String name, opcode, operand, comment;

		asmTable.add(new GNUAsmLine(null, null, null, "Initialized data"));
		asmTable.add(new GNUAsmLine(null, ".text", null, null));
		asmTable.add(new GNUAsmLine(null, ".align", alignment, "align to " + (2 * new Integer(alignment).intValue()) + " byte boundary"));

		while (i.hasNext())
		{
			Map.Entry e = (Map.Entry)i.next();
			Symbol s = (Symbol)e.getValue();
			
			if (s.value == null)
			{
				// skip over uninitialized data
				continue;
			}
			
			if (s.type.equals("LABEL") || s.type.equals("PROCEDURE"))
			{
				if (s.global == true)
				{
				   asmTable.add(new GNUAsmLine(null, ".globl", s.name, null));
				}
				continue;
			 }
         
			name = s.name;
			opcode = null;
			operand = s.value;
			comment = s.type;

			if (s.global == true)
			{
//				name = name + ":";
			}

			if (s.type.equals("STRING"))
			{
				opcode = ".ascii";
			}
			else
			if (s.type.equals("INTEGER"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					if (s.size > maxIntegerValue)
					{
						System.err.println("WARNING: " + s.size + " exceeds " + maxIntegerValue);
					}
					
					opcode = ".short";
				}
				else
				{
					// INTEGER constants are loaded immediate
					continue;
				}
			}
			else
			if (s.type.equals("BYTE"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					if (s.size > maxByteValue)
					{
						System.err.println("WARNING: " + s.size + " exceeds " + maxByteValue);
					}
					
					opcode = ".byte";
				}
				else
				{
					// BYTE constants are loaded immediate
					continue;
				}
			}
			else
			if (s.type.equals("BOOLEAN"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(s))
				{			
					opcode = ".byte";
					if (s.value.equals("TRUE") || s.value.equals("1"))
					{
						operand = "1";
					}
					else
					{
						operand = "0";
					}
				}
				else
				{
					continue;
				}
			}
			else
			if (s.type.equals("REAL"))
			{
				opcode = ".double";
				operand = s.value;
			}
			
			asmTable.add(new GNUAsmLine(s.name, opcode, operand, comment));
			if (s.type.equals("STRING"))
			{
				asmTable.add(new GNUAsmLine(null, ".byte", "0", null));
			}
		}
	}




	static void nop(Quad q)
	{
		asmTable.add(new GNUAsmLine(q.label, null, null, null));
	}
	
	static void gt(Quad q)
	{
		asmTable.add(new GNUAsmLine(q.label, "bl", q.dst, q.comment));
	}
	
	static void logical(Quad q, String operation)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";

		if (!quadTable.symbolIsReadOnlyConstant(src1))
		{
			asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
			asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
		}
		else
		{
         if (src1.value.equals("TRUE") || src1.value.equals("1"))
         {
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",1", q.comment));
         }
         else
         {
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",0", q.comment));
         }
		}
		if (!quadTable.symbolIsReadOnlyConstant(src2))
		{
			asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
			asmTable.add(new GNUAsmLine(null, "lbz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
			asmTable.add(new GNUAsmLine(null, operation, regdst + "," + regsrc1 + "," + regsrc2, null));
		}
		else
		{
         if (src1.value.equals("TRUE") || src1.value.equals("1"))
         {
				asmTable.add(new GNUAsmLine(null, operation + "i.", regdst + "," + regdst + ",1", null));
         }
         else
         {
				asmTable.add(new GNUAsmLine(null, operation + "i.", regdst + "," + regdst + ",0", null));
         }
		}
		asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc2 + "," + regsrc2 + "," + lo16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "stb", regdst + "," + "0(" + regsrc2 + ")", null));
	}
	
	static void _not(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";
      
		if (!quadTable.symbolIsReadOnlyConstant(src1))
		{
			asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
			asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
		}
		else
		{
			asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + "," + src1.value, q.comment));
		}
      
		asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + ",1", null));
		asmTable.add(new GNUAsmLine(null, "bne", null, null));
		asmTable.add(new GNUAsmLine(null, "ldi", regsrc1 + ",1", null));
		asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc2 + "," + lo16(q.src2), null));
		asmTable.add(new GNUAsmLine(null, "sth", regsrc1 + "," + regsrc2, null));
		asmTable.add(new GNUAsmLine(null, "b", null, null));
		asmTable.add(new GNUAsmLine(null, "ldi", regsrc1 + ",0", null));
		asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc2 + "," + lo16(q.src2), null));
	}
	
	static void _neg(Quad q)
	{
		Symbol s = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";
		String loadop = null;
		String storeop = null;
		
		if (s.type.equals("BYTE"))
		{
			loadop = "lbz";
			storeop = "stb";
		}
		else
		if (s.type.equals("INTEGER"))
		{
			loadop = "lhz";
			storeop = "sth";
		}
		else
		if (s.type.equals("REAL"))
		{
			asmTable.add(new GNUAsmLine(null, null, null, "TODO: neg(REAL)"));
			return;
		}
		else
		{
			System.out.println("_neg() encountered an unsupported type.");
			return;
		}
		asmTable.add(new GNUAsmLine(q.label, "addis", regdst + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, loadop, regsrc1 + ",0(" + regdst + ")", null));
		asmTable.add(new GNUAsmLine(null, "addi", regsrc2 + ",0,0", null));
		asmTable.add(new GNUAsmLine(null, "orc", regsrc1 + "," + regsrc2 + "," + regsrc1, "take twos complement"));
		asmTable.add(new GNUAsmLine(null, "addi", regsrc1 + "," + regsrc1 + ",1", null));
		asmTable.add(new GNUAsmLine(null, storeop, regsrc1 + ",0(" + regdst + ")", null));
	}

	
	/*
	Legal additions/subtractions:

		Booleans cannot be added/subtracted

		Bytes, Integers and Reals can be added/subtracted
		BYTE +/- BYTE = 0-255
		INTEGER +/- INTEGER = -32768 to 32767
		REAL +/- REAL = REAL range
		BYTE +/- INTEGER = -32768 to 32767
		BYTE +/- REAL = REAL range
		INTEGER +/- REAL = REAL range
	*/
	static void addsub(Quad q, String operation)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";

		// string addition
		if (src1.type.equals("STRING"))
		{
			if (src2.type.equals("STRING") && operation.equals("add"))
			{
				Integer size = dst.size;
				
				asmTable.add(new GNUAsmLine(null, "addis", "r3,0," + hi16(q.src1), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r3,r3," + lo16(q.src1), null));
			
				asmTable.add(new GNUAsmLine(null, "addis", "r4,0," + hi16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r4,r4," + lo16(q.src2), null));
			
				asmTable.add(new GNUAsmLine(null, "addis", "r5,0," + hi16(q.dst), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r5,r5," + lo16(q.dst), null));
				
				asmTable.add(new GNUAsmLine(null, "bl", "addstring", "addstring(src1addr, src2addr, dstaddr)"));
			}
			else
			{
				System.out.println("STRING can only be added to STRING");
			}
			return;
		}

		// src1
		if (!quadTable.symbolIsReadOnlyConstant(src1))
		{
			String srcload = null;
			
			if (src1.type.equals("BYTE"))
			{
				srcload = "lbz";
			}
			else if (src1.type.equals("INTEGER"))
			{
				srcload = "lha";
			}
			else if (src1.type.equals("REAL"))
			{
			}
			
			asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
			asmTable.add(new GNUAsmLine(null, srcload, regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
		}
		else
		{
			asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + "," + src1.value, q.comment));
		}

		// src2
		if (!quadTable.symbolIsReadOnlyConstant(src2))
		{
			String srcload = null;
			
			if (src2.type.equals("BYTE"))
			{
				srcload = "lbz";
			} 
			else if (src2.type.equals("INTEGER"))
			{
				srcload = "lha";
			}
			else if (src2.type.equals("REAL"))
			{
			}

			asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
			asmTable.add(new GNUAsmLine(null, srcload, regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
		}
		else
		{
			asmTable.add(new GNUAsmLine(null, "li", regsrc2 + "," + src2.value, null));
		}

		
		asmTable.add(new GNUAsmLine(null, operation, regdst + "," + regsrc1 + "," + regsrc2, null));
		asmTable.add(new GNUAsmLine(null, "addis", regsrc1 + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc1 + "," + regsrc1 + "," + lo16(q.dst), null));

		// dst
		if (dst.type.equals("BYTE"))
		{
			asmTable.add(new GNUAsmLine(null, "stb", regdst + ",0(" + regsrc1 + ")", null));
		}
		else
		if (dst.type.equals("INTEGER"))
		{
			//					asmTable.add(new GNUAsmLine(null, "sex", null, null));
			asmTable.add(new GNUAsmLine(null, "sth", regdst + ",0(" + regsrc1 + ")", null));
		}
		else
		if (dst.type.equals("REAL"))
		{
			asmTable.add(new GNUAsmLine(null, null, null, "TODO: REAL = X + Y"));
		}
	}
	

	/* Legal multiplications:

		Booleans cannot be multiplied

		Bytes, Integers and Reals can be multiplied together
		BYTE * BYTE = 0-255
		INTEGER * INTEGER = -32768 to 32767
		REAL * REAL = REAL range
		BYTE * INTEGER = -32768 to 32767
		BYTE * REAL = REAL range
		INTEGER * REAL = REAL range
	*/
	static void multdiv(Quad q, String operation, Boolean modulo)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";

		// src1
		if (!quadTable.symbolIsReadOnlyConstant(src1))
		{
			String srcload = null;
			
			if (src1.type.equals("BYTE"))
			{
				srcload = "lbz";
			}
			else if (src1.type.equals("INTEGER"))
			{
				srcload = "lha";
			}
			else if (src1.type.equals("REAL"))
			{
			}
			
			asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
			asmTable.add(new GNUAsmLine(null, srcload, regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
		}
		else
		{
			asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + "," + src1.value, q.comment));
		}

		// src2
		if (!quadTable.symbolIsReadOnlyConstant(src2))
		{
			String srcload = null;

			if (src2.type.equals("BYTE"))
			{
				srcload = "lbz";
			}
			else if (src2.type.equals("INTEGER"))
			{
				srcload = "lha";
			}
			else if (src2.type.equals("REAL"))
			{
			}

			asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
			asmTable.add(new GNUAsmLine(null, srcload, regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
		}
		else
		{
			asmTable.add(new GNUAsmLine(null, "li", regsrc2 + "," + src2.value, null));
		}
			
		// dst	
		asmTable.add(new GNUAsmLine(null, operation, regdst + "," + regsrc1 + "," + regsrc2, null));
		if (modulo)
		{
			asmTable.add(new GNUAsmLine(null, "mullw", regdst + "," + regdst + "," + regsrc2, null));
			asmTable.add(new GNUAsmLine(null, "subf", regdst + "," + regdst + "," + regsrc1, null));
		}
		asmTable.add(new GNUAsmLine(null, "addis", regsrc1 + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc1 + "," + regsrc1 + "," + lo16(q.dst), null));

		if (dst.type.equals("BYTE"))
		{
			asmTable.add(new GNUAsmLine(null, "stb", regdst + ",0(" + regsrc1 + ")", null));
		}
		else
		if (dst.type.equals("INTEGER"))
		{
			asmTable.add(new GNUAsmLine(null, "sth", regdst + ",0(" + regsrc1 + ")", null));
		}
		else
		if (dst.type.equals("REAL"))
		{
			asmTable.add(new GNUAsmLine(null, null, null, "TODO: REAL = ? * ?"));
		}
	}
	
	static void rem(Quad q)
	{
	}

	
        static void stack(Quad q)
        {
                Symbol src1 = (Symbol)symbolTable.get(q.src1);
                Symbol src2 = (Symbol)symbolTable.get(q.src2);
                Symbol dst = (Symbol)symbolTable.get(q.dst);
				String regsrc1 = "r12";
				String regsrc2 = "r13";
				String regdst  = "r11";

                if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
                {
                	Integer sizeOf = 4;
					asmTable.add(new GNUAsmLine(q.label, "addis", regdst + ",0," + hi16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "lbz", regdst + "," + lo16(q.dst) + "(" + regdst + ")", null));
					asmTable.add(new GNUAsmLine(null, "addi", "r1,r1,-4", "update stack"));
					asmTable.add(new GNUAsmLine(null, "stw", regdst + ",0(r1)", "save on stack"));
					stackOffset += sizeOf;
                }
                else if (dst.type.equals("INTEGER"))
                {
                	Integer sizeOf = 4;
					asmTable.add(new GNUAsmLine(q.label, "addis", regdst + ",0," + hi16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "lha", regdst + "," + lo16(q.dst) + "(" + regdst + ")", null));
					asmTable.add(new GNUAsmLine(null, "addi", "r1,r1,-" + sizeOf.toString(), "update stack"));
					asmTable.add(new GNUAsmLine(null, "stw", regdst + ",0(r1)", "save on stack"));
					stackOffset += sizeOf;
                }
                else if (dst.type.equals("REAL"))
                {
                }
        }

        static void unstack(Quad q)
        {
                Symbol src1 = (Symbol)symbolTable.get(q.src1);
                Symbol src2 = (Symbol)symbolTable.get(q.src2);
                Symbol dst = (Symbol)symbolTable.get(q.dst);
				String regsrc1 = "r12";
				String regsrc2 = "r13";
				String regdst = "r11";

                if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
                {
					asmTable.add(new GNUAsmLine(q.label, "lbz", regsrc1 + ",0(r1)", null));
					asmTable.add(new GNUAsmLine(null, "addis", regdst + ",0," + hi16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "stb", regsrc1 + ",0(" + regdst + ")", null));
					asmTable.add(new GNUAsmLine(null, "addi", "r1,r1,4", "adjust stack"));
					stackOffset += 4;
                }
                else if (dst.type.equals("INTEGER"))
                {
					asmTable.add(new GNUAsmLine(q.label, "lwz", regsrc1 + ",0(r1)", null));
					asmTable.add(new GNUAsmLine(null, "addis", regdst + ",0," + hi16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
					asmTable.add(new GNUAsmLine(null, "sth", regsrc1 + ",0(" + regdst + ")", null));
					asmTable.add(new GNUAsmLine(null, "addi", "r1,r1,4", "adjust stack"));
					stackOffset += 4;
                }
                else if (dst.type.equals("REAL"))
                {
                }
        }

	/* Legal copies:

		Boolean is an 8-bit value (0 = FALSE, 1 = TRUE)
		BOOLEAN = BOOLEAN

		Byte is an Unsigned 8-bit value (0-255)
		BYTE = BYTE
		BYTE = INTEGER % 256
		BYTE = REAL % 256
		
		Integer is a Signed 16-bit value (-32768 to 32767)
		INTEGER = BYTE
		INTEGER = INTEGER
		INTEGER = REAL % 65536
		
		REAL = BYTE
		REAL = INTEGER
		REAL = REAL
		
		STRING = STRING
	 */
	static void cp(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";
      
		if (src1.type.equals("BOOLEAN"))
		{
			if (dst.type.equals("BOOLEAN"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(src1))
				{
					asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
					asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
				}
				else
				{
					if (src1.value.equals("TRUE") || src1.value.equals("1"))
					{
						asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",1", q.comment));
					}
					else
					{
						asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",0", q.comment));
					}
				}
				asmTable.add(new GNUAsmLine(null, "addis", regdst + ",0," + hi16(q.dst), null));
				asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
				asmTable.add(new GNUAsmLine(null, "stb", regsrc1 + ",0(" + regdst + ")", null));
			}
			else
			{
				System.out.println("BOOLEAN can only be assigned to BOOLEAN");
			}
			return;
		}

		else
		if (src1.type.equals("STRING"))
		{
			if (dst.type.equals("STRING"))
			{
				Integer size = src1.size;
				
				asmTable.add(new GNUAsmLine(null, "li", "r3," + (src1.size), null));
				asmTable.add(new GNUAsmLine(null, "addis", "r4,0," + hi16(q.src1), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r4,r4," + lo16(q.src1), null));
				
				size = dst.size;
				
				asmTable.add(new GNUAsmLine(null, "li", "r5," + (dst.size), null));
				asmTable.add(new GNUAsmLine(null, "addis", "r6,0," + hi16(q.dst), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r6,r6," + lo16(q.dst), null));
				
				asmTable.add(new GNUAsmLine(null, "bl", "copystring", "copystring(srcsize, srcaddr, dstsize, dstaddr)"));
			}
			else
			{
				System.out.println("STRING can only be assigned to STRING");
			}
			return;
		}
		
		else
		if (src1.type.equals("REAL") || dst.type.equals("REAL"))
		{
			asmTable.add(new GNUAsmLine(null, null, null, "TODO: REAL copying is not supported yet"));
			return;
		}
		
	
		if (!quadTable.symbolIsReadOnlyConstant(src1))
		{
			String op = null;
			
			if (src1.type.equals("BYTE"))
			{
				op = "lbz";
			}
			else if (src1.type.equals("INTEGER"))
			{
				op = "lhz";
			}
			else if (src1.type.equals("REAL"))
			{
			}

			asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
			asmTable.add(new GNUAsmLine(null, op, regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
		}
		else
		{
			Integer constantValue = new Integer(src1.value).intValue();
			if (constantValue > 32767)
			{
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + "," + hi16(src1.value), q.comment));
				asmTable.add(new GNUAsmLine(q.label, "addi", regsrc1 + "," + regsrc1 + "," + lo16(src1.value), q.comment));
			}
			else
			{
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + "," + src1.value, q.comment));
			}
		}
		
		String op = null;
		
		if (dst.type.equals("BYTE"))
		{
			op = "stb";
		}
		else
		if (dst.type.equals("INTEGER"))
		{
			op = "sth";
		}
		else
		if (dst.type.equals("REAL"))
		{
			asmTable.add(new GNUAsmLine(null, null, null, "TODO: REAL = ?"));
		}

		asmTable.add(new GNUAsmLine(null, "addis", regdst + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, op, regsrc1 + ",0(" + regdst + ")", null));
	}

	static void gtconditional(Quad q)
	{
		String opcode = null;
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";
		
		if (src1.type.equals("BOOLEAN"))
		{
			if (!src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
			}

			if (!quadTable.symbolIsReadOnlyConstant(src1))
			{
				asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
			}
			else
			{
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1+ "," + src1.value, q.comment));
			}
			if (!quadTable.symbolIsReadOnlyConstant(src2))
			{
				asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, "lbz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
				asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
			}
			else
			{
				if (src2.value.equals("TRUE") || src2.value.equals("1"))
				{
					asmTable.add(new GNUAsmLine(null, "li", regsrc2 + ",1", null));
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "li", regsrc2 + ",0", null));
				}
			}
		}
		else if (src2.type.equals("BOOLEAN"))
		{
			System.out.println("BOOLEAN can only be compared with BOOLEAN");
			return;
		}
		else
		{
			if (!quadTable.symbolIsReadOnlyConstant(src1))
			{
				String op = null;
				
				if (src1.type.equals("BYTE"))
				{
					op = "lbz";
				}
				else if (src1.type.equals("INTEGER"))
				{
					op = "lhz";
				}
				else if (src1.type.equals("REAL"))
				{
				}
				asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, op, regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
			}
			else
			{
				asmTable.add(new GNUAsmLine(null, "li", regsrc1 + "," + src1.value, null));
			}

			if (!quadTable.symbolIsReadOnlyConstant(src2))
			{
				String op = null;
				
				if (src2.type.equals("BYTE"))
				{
					op = "lbz";
				}
				else if (src2.type.equals("INTEGER"))
				{
					op = "lhz";
				}
				else if (src2.type.equals("REAL"))
				{
				}
				asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, op, regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
				asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
			}
			else
			{
				asmTable.add(new GNUAsmLine(null, "li", regsrc2 + "," + src2.value, null));
			}
		}
		
		asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			

		if (q.opcode.equals("gt>="))
		{
			opcode = "bge";
		}
		else
		if (q.opcode.equals("gt<="))
		{
			opcode = "ble";
		}
		else
		if (q.opcode.equals("gt>"))
		{
			opcode = "bgt";
		}
		else
		if (q.opcode.equals("gt<"))
		{
			opcode = "blt";
		}
		else
		if (q.opcode.equals("gt!="))
		{
			opcode = "bne";
		}
		else
		{
			opcode = "beq";
		}

		asmTable.add(new GNUAsmLine(null, opcode, q.dst, null));
	}
	
	static void relation(Quad q)
	{
		String opcode = null;
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String dstreg = "r14";

		if (q.opcode.equals(">"))
		{
			opcode = "bgt";
		}
		else
		if (q.opcode.equals("<"))
		{
			opcode = "blt";
		}
		else
		if (q.opcode.equals(">="))
		{
			opcode = "bge";
		}
		else
		if (q.opcode.equals("<="))
		{
			opcode = "ble";
		}
		else
		if (q.opcode.equals("="))
		{
			opcode = "beq";
		}
		else
		{
			opcode = "bne";
		}

		if (src1.type.equals("BOOLEAN"))
		{
			if (!src2.type.equals("BOOLEAN"))
			{
				System.out.println("BOOLEAN can only be compared with BOOLEAN");
				return;
			}

			if (!quadTable.symbolIsReadOnlyConstant(src1))
			{
				asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
			}
			else
			{
				if (src1.value.equals("TRUE") || src1.value.equals("1"))
				{
					asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",1", q.comment));
				}
				else
				{
					asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",0", q.comment));
				}
			}
			
			if (!quadTable.symbolIsReadOnlyConstant(src2))
			{
				asmTable.add(new GNUAsmLine(null, "addis", regsrc2 + ",0," + hi16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, "lbz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
				asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
			}
			else
			{
				if (src2.value.equals("TRUE") || src2.value.equals("1"))
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + ",1", null));			
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + ",0", null));			
				}
			}
		}

		else
		if (src1.type.equals("BYTE"))
		{
			if (!quadTable.symbolIsReadOnlyConstant(src1))
			{
				asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
//				asmTable.add(new GNUAsmLine(null, "extsb", regsrc1 + "," + regsrc1, null));			
			}
			else
			{
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",1", q.comment));
			}

			if (src2.type.equals("BYTE"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(src2))
				{
					asmTable.add(new GNUAsmLine(q.label, "addis", regsrc2 + ",0," + hi16(q.src2), q.comment));
					asmTable.add(new GNUAsmLine(null, "lbz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
//					asmTable.add(new GNUAsmLine(null, "extsb", regsrc2 + "," + regsrc2, null));			
					asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + "," + src2.value, null));			
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(src2))
				{
					asmTable.add(new GNUAsmLine(q.label, "addis", regsrc2 + ",0," + hi16(q.src2), q.comment));
					asmTable.add(new GNUAsmLine(null, "lhz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
					asmTable.add(new GNUAsmLine(null, "extsh", regsrc2 + "," + regsrc2, null));			
					asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + "," + src2.value, null));			
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
			}
		}

		else
		if (src1.type.equals("INTEGER"))
		{
			if (!quadTable.symbolIsReadOnlyConstant(src1))
			{
				asmTable.add(new GNUAsmLine(q.label, "addis", regsrc1 + ",0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, "lhz", regsrc1 + "," + lo16(q.src1) + "(" + regsrc1 + ")", null));
				asmTable.add(new GNUAsmLine(null, "extsh", regsrc1 + "," + regsrc1, null));			
			}
			else
			{
				asmTable.add(new GNUAsmLine(q.label, "li", regsrc1 + ",1", q.comment));
			}

			if (src2.type.equals("BYTE"))
			{
				asmTable.add(new GNUAsmLine(null, "extsh", regsrc1 + "," + regsrc1, null));			
				if (!quadTable.symbolIsReadOnlyConstant(src2))
				{
					asmTable.add(new GNUAsmLine(q.label, "addis", regsrc2 + ",0," + hi16(q.src2), q.comment));
					asmTable.add(new GNUAsmLine(null, "lbz", regsrc2 + "," + lo16(q.src2 + "+1") + "(" + regsrc2 + ")", null));
//					asmTable.add(new GNUAsmLine(null, "extsb", regsrc2 + "," + regsrc2, null));			
					asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + "," + src2.value, null));			
				}
			}
			else
			if (src2.type.equals("INTEGER"))
			{
				if (!quadTable.symbolIsReadOnlyConstant(src2))
				{
					asmTable.add(new GNUAsmLine(q.label, "addis", regsrc2 + ",0," + hi16(q.src2), q.comment));
					asmTable.add(new GNUAsmLine(null, "lhz", regsrc2 + "," + lo16(q.src2) + "(" + regsrc2 + ")", null));
					asmTable.add(new GNUAsmLine(null, "extsh", regsrc2 + "," + regsrc2, null));			
					asmTable.add(new GNUAsmLine(null, "cmp", "0,0," + regsrc1 + "," + regsrc2, null));			
				}
				else
				{
					asmTable.add(new GNUAsmLine(null, "cmpi", "0,0," + regsrc1 + "," + src2.value, null));			
				}
			}
			else
			if (src2.type.equals("REAL"))
			{
			}
		}

		else
		if (src1.type.equals("REAL"))
		{
			if (src2.type.equals("BYTE"))
			{
			}
			else
			if (src2.type.equals("INTEGER"))
			{
			}
			else
			if (src2.type.equals("REAL"))
			{
			}
		}

		else
		if (src1.type.equals("STRING"))
		{
			if (src2.type.equals("STRING"))
			{
				asmTable.add(new GNUAsmLine(q.label, "addis", "r3,0," + hi16(q.src1), q.comment));
				asmTable.add(new GNUAsmLine(null, "ori", "r3,r3," + lo16(q.src1), null));
				asmTable.add(new GNUAsmLine(null, "addis", "r4,0," + hi16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, "ori", "r4,r4," + lo16(q.src2), null));
				asmTable.add(new GNUAsmLine(null, "bl", "comparestring", null));
				asmTable.add(new GNUAsmLine(null, "cmpi", "0,0,r3,0", null));
			}
			else
			{
				System.err.printf("illegal comparison: STRING to another type\n");
				System.exit(1);
			}
		}

		String bra1 = "L" + asmTable.size();
		asmTable.add(new GNUAsmLine(null, opcode, bra1, null));
		asmTable.add(new GNUAsmLine(null, "li", regsrc1 + ",0", null));
		String bra2 = "L" + asmTable.size();
		asmTable.add(new GNUAsmLine(null, "b", bra2, null));
		asmTable.add(new GNUAsmLine(bra1, "li", regsrc1 + ",1", null));
		asmTable.add(new GNUAsmLine(bra2, "addis", regsrc2 + ",0," + hi16(q.dst), q.comment));
		asmTable.add(new GNUAsmLine(null, "ori", regsrc2 + "," + regsrc2 + "," + lo16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "stb", regsrc1 + "," + "0(" + regsrc2 + ")", null));
	}
	
	static void ret(Quad q)
	{
		asmTable.add(new GNUAsmLine(q.label, "addi", "r1,r1,16", "destroy the stack frame"));
		asmTable.add(new GNUAsmLine(null, "lwz", "r0,8(r1)", "get original link reg value saved earlier"));
		asmTable.add(new GNUAsmLine(null, "mtlr", "r0", "place it back in link register"));
		asmTable.add(new GNUAsmLine(null, "blr", null, "return"));
	}
	
	static void _exit(Quad q)
	{
		Symbol s = (Symbol)symbolTable.get(q.dst);

		if (s.type.equals("BYTE"))
		{
			asmTable.add(new GNUAsmLine(q.label, "ldb", q.dst + ",u", q.comment));
			asmTable.add(new GNUAsmLine(null, "sex", null, null));
		}
		else
		{
		         asmTable.add(new GNUAsmLine(null, "addis", "r3,0," + hi16(q.dst), null));
		         asmTable.add(new GNUAsmLine(null, "lwz", "r3," + lo16(q.dst) + "(r3)", null));
		}
		asmTable.add(new GNUAsmLine(null, "li", "r0,1", null));
		asmTable.add(new GNUAsmLine(null, "sc", null, null));
	}
	
	static void call(Quad q)
	{
		asmTable.add(new GNUAsmLine(null, "bl", q.dst, null));
	}
	
	static void stackpeek(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";

		Integer stackOffset = (dst.param - 1) * 4 + 16;
		asmTable.add(new GNUAsmLine(q.label, "lwz", regsrc1 + "," + stackOffset.toString() + "(r1)", null));
		asmTable.add(new GNUAsmLine(null, "addis", regdst + ",0," + hi16(q.dst), null));
		asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
		if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
		{
			asmTable.add(new GNUAsmLine(null, "stb", regsrc1 + ",0(" + regdst + ")", null));
		}
		if (dst.type.equals("INTEGER"))
		{
			asmTable.add(new GNUAsmLine(null, "sth", regsrc1 + ",0(" + regdst + ")", null));
		}
		else if (dst.type.equals("REAL"))
		{
		}
	}
	
	static void stackpoke(Quad q)
	{
		Symbol src1 = (Symbol)symbolTable.get(q.src1);
		Symbol src2 = (Symbol)symbolTable.get(q.src2);
		Symbol dst = (Symbol)symbolTable.get(q.dst);
		String regsrc1 = "r12";
		String regsrc2 = "r13";
		String regdst  = "r11";

		Integer stackOffset = (dst.param -1) * 4 + 16;	
		if (dst.type.equals("BOOLEAN") || dst.type.equals("BYTE"))
		{
			asmTable.add(new GNUAsmLine(q.label, "addis", regdst + ",0," + hi16(q.dst), null));
			asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
			asmTable.add(new GNUAsmLine(null, "lbz", regsrc1 + ",0(" + regdst + ")", null));
			asmTable.add(new GNUAsmLine(null, "stw", regsrc1 + "," + stackOffset.toString() + "(r1)", null));
		}
		else if (dst.type.equals("INTEGER"))
		{
			asmTable.add(new GNUAsmLine(q.label, "addis", regdst + ",0," + hi16(q.dst), null));
			asmTable.add(new GNUAsmLine(null, "ori", regdst + "," + regdst + "," + lo16(q.dst), null));
			asmTable.add(new GNUAsmLine(null, "lhz", regsrc1 + ",0(" + regdst + ")", null));
			asmTable.add(new GNUAsmLine(null, "stw", regsrc1 + "," + stackOffset.toString() + "(r1)", null));
		}
		else if (dst.type.equals("REAL"))
		{
		}
	}
	
	static void translate()
	{
		asmTable.add(new GNUAsmLine(null, ".align", alignment, "align to " + (2 * new Integer(alignment).intValue()) + " byte boundary"));

		for (Iterator it = quadTable.iterator(); it.hasNext(); )
		{
			Quad q = (Quad)it.next();
			asmTable.add(new GNUAsmLine(null, null, null, q.prettyLine()));
			if (symbolTable.symbolIsProcedure(q.label))
			{
				// we're at the start of a procedure... generate prologue code
				asmTable.add(new GNUAsmLine(q.label, "mflr", "r0", "move link register to r0"));
				asmTable.add(new GNUAsmLine(null, "stw", "r0,8(r1)", "save r0 on stack"));
				asmTable.add(new GNUAsmLine(null, "stwu", "r1,-16(r1)", "adjust stack"));
				q.label = "";
			}
			
			if (q.opcode.equalsIgnoreCase("nop"))
			{
				nop(q);
			}
			else if (q.opcode.equalsIgnoreCase("gt"))
			{
				gt(q);
			}
			else if (q.opcode.equalsIgnoreCase("and"))
			{
				logical(q, "and");
			}
			else if (q.opcode.equalsIgnoreCase("or"))
			{
				logical(q, "or");
			}
			else if (q.opcode.equalsIgnoreCase("not"))
			{
				_not(q);
			}
			else if (q.opcode.equalsIgnoreCase("neg"))
			{
				_neg(q);
			}
			else if (q.opcode.equalsIgnoreCase("+"))
			{
				addsub(q, "add");
			}
			else if (q.opcode.equalsIgnoreCase("-"))
			{
				addsub(q, "sub");
			}
			else if (q.opcode.equalsIgnoreCase("*"))
			{
				multdiv(q, "mullw", false);
			}
			else if (q.opcode.equalsIgnoreCase("/"))
			{
				multdiv(q, "divw", false);
			}
			else if (q.opcode.equalsIgnoreCase("%"))
			{
				multdiv(q, "divw", true);
			}
			else if (q.opcode.equalsIgnoreCase("stack"))
			{
				stack(q);
			}
			else if (q.opcode.equalsIgnoreCase("unstack"))
			{
				unstack(q);
			}
			else if (q.opcode.equalsIgnoreCase("rem"))
			{
				rem(q);
			}
			else if (q.opcode.equalsIgnoreCase("cp"))
			{
				cp(q);
			}
			else
			if (q.opcode.equalsIgnoreCase("gt!=")
				|| q.opcode.equalsIgnoreCase("gt=")
				|| q.opcode.equalsIgnoreCase("gt>=")
				|| q.opcode.equalsIgnoreCase("gt<=")
				|| q.opcode.equalsIgnoreCase("gt>")
				|| q.opcode.equalsIgnoreCase("gt<")
			)
			{
				gtconditional(q);
			}
			else if (q.opcode.equalsIgnoreCase(">")
			|| q.opcode.equalsIgnoreCase("<")
			|| q.opcode.equalsIgnoreCase(">=")
			|| q.opcode.equalsIgnoreCase("<=")
			|| q.opcode.equalsIgnoreCase("=")
			|| q.opcode.equalsIgnoreCase("<>")
			)
			{
				relation(q);
			}
			else if (q.opcode.equalsIgnoreCase("ret"))
			{
				ret(q);
			}
			else if (q.opcode.equalsIgnoreCase("exit"))
			{
				_exit(q);
			}
			else if (q.opcode.equalsIgnoreCase("call"))
			{
				call(q);
			}
			else if (q.opcode.equalsIgnoreCase("stackpeek"))
			{
				stackpeek(q);
			}
			else if (q.opcode.equalsIgnoreCase("stackpoke"))
			{
				stackpoke(q);
			}
			else
			{
				System.err.printf("unknown instruction '%s'\n", q.opcode);
				System.exit(1);
			}
		}
	}
}
